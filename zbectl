#!/bin/bash

# Utility for managing ZFS Boot Environments in Arch Linux
# 
# Source at <https://github.com/Finic8/zbectl>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

usage() {
	echo "zbectl: Utility for managing ZFS Boot Environments in Arch Linux"
	echo "zbectl list"
	echo "zbectl create [source] <target>"
	echo "zbectl rename [source] <target>"
	echo "zbectl activate <target> [kernel]"
	echo "zbectl destroy <target>"
	echo "zbectl install"
	exit 0
}
[ $# -eq 0 ] && usage

check_root() {
	if [ $(id -u) != 0 ]; then
		echo "ERROR: Must be ran as root"
		exit 1
	fi
}
ROOTFS=$( mount | awk '/ \/ / {print $1}' )
ESP=/boot/efi
GRUBCFG=$ESP/grub/grub.cfg

if echo ${ROOTFS} | grep -q "^/dev/"
then
	echo "ERROR: The system does not boot from a ZFS pool"
	exit 1
fi

POOL=$( echo ${ROOTFS} | awk -F '/' '{print $1}' )

if [ $( echo ${ROOTFS} | awk -F '/' '{print NF}' ) -lt 3 ]
then
	echo "ERROR: This system is not configured for boot environments"
	exit 1
fi

check_target() {
	# check if name is usable
	local TARGET=${1}
	local sane_name=$( echo "$TARGET" | tr -c -d 'a-zA-Z0-9-_.,' )
	if [[ "$1" != "$sane_name" ]]
	then
		echo "ERROR: name: '${NAME_NEW}' contains invalid charaters"
		echo "Possible name: '${NAME_SANITY}'"
		exit 1
	fi
	unset sane_name

	# check if boot environment does already exist
	if zfs list -H -o name $POOL/ROOT/$TARGET &> /dev/null
	then
		echo "ERROR: Boot environment '$TARGET' does already exist"
		exit 1
	fi
}
check_env_exist() {
	local TARGET=${1}
	if ! zfs list -H -o name $POOL/ROOT/$TARGET &> /dev/null
	then
		echo  "ERROR: Boot environment '$TARGET' does not exist"
		exit 1
	fi
}
check_env_in_use() {
	local TARGET=${1}
	if [ "$POOL/ROOT/$TARGET" == $ROOTFS ]
	then
		echo "ERROR: Target boot environment '$TARGET' is in use"
		exit 1
	fi
}
create_clone() {
	# create a clone of the $TARGET boot environment
	FMT=$(date "+%Y-%m-%d-%H:%M:%S")
	zfs snapshot -r $POOL/ROOT/$SOURCE@zbectl_${FMT}_$TARGET
	zfs clone -o canmount=noauto -o mountpoint=/ $POOL/ROOT/$SOURCE@zbectl_${FMT}_$TARGET $POOL/ROOT/$TARGET
}
update_grub() {
	grub-mkconfig -o $GRUBCFG &> /dev/null
	exit 0
}

if [ $1 == 'list' ]
then
	zfs list -r -o name,used,available,referenced,mounted "$POOL"/ROOT
	echo
	# determine default
	if [ ! -s $GRUBCFG ];
	then
		echo "ERROR: grub.cfg does not exist. Run zbectl install first"
		exit 1
	fi
	DEFAULT="$(grep GRUB_DEFAULT /etc/default/grub)"
	echo "Default entry: ${DEFAULT#GRUB_DEFAULT=}"
	exit 0
else
	check_root
fi
if [ $1 == 'destroy' ]
then
	[ $# -ne 2 ] && usage
	TARGET=$(basename "${2}")
	check_env_exist $TARGET
	check_env_in_use $TARGET
	# promote dependent clones
	zfs list -H -t all -o name,origin -r ${POOL} | while read NAME ORIGIN
	do
		if echo "${ORIGIN}" | grep -q -E "${POOL}/ROOT/${TARGET}(/.*@|@)" 2> /dev/null
		then
			zfs promote ${NAME}
		fi
	done
	zfs destroy -r $POOL/ROOT/$TARGET
	update_grub
	
elif [ $1 == 'create' ]
then
	if [ $# -eq 3 ]
	then
		TARGET=$(basename "${3}")
		check_target $TARGET
		SOURCE=$(basename "${2}")
		check_env_exist $SOURCE
	elif [ $# -eq 2 ]
	then
		TARGET=$(basename "${2}")
		check_target $TARGET
		SOURCE=$(basename "$ROOTFS")
	else
		usage
	fi
	create_clone
	update_grub

elif [ $1 == 'rename' ]
then
	SOURCE=$(basename "${2}")
	check_env_exist $SOURCE
	check_env_in_use $SOURCE
	TARGET=$(basename "${3}")
	check_target $TARGET
	zfs rename $POOL/ROOT/$SOURCE $POOL/ROOT/$TARGET
	update_grub

elif [ $1 == 'install' ]
then
	grub-install --target=x86_64-efi --efi-directory=$ESP --boot-directory=$ESP --bootloader-id=boot
	# prevent grub from creating unbootable and therfore useless entries
	ln -sf /dev/null /etc/grub.d/10_linux
	# trigger the newly installed udev rule
	udevadm trigger
	update_grub

elif [ $1 == 'activate' ]
then
	[ $# -ge 3 ] && usage
	if [ $# -eq 1 ]
	then
		echo "Avialiable environments:"
		grep ^menuentry $GRUBCFG | cut -d "'" -f2
		exit 0
	fi
	while read ENTRY
	do
		if [ "$ENTRY" == "$TARGET" ]
		then
			sed -i "s/GRUB_DEFAULT.*/GRUB_DEFAULT=$ENTRY" /etc/default/grub
			update_grub
		fi
	done < <(grep ^menuentry $GRUBCFG | cut -d "'" -f2)
	echo "ERROR: Specified entry does not exist"
	exit 1
else
	usage
fi
